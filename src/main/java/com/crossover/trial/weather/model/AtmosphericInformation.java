package com.crossover.trial.weather.model;

import java.util.Optional;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

/**
 * encapsulates sensor information for a particular location
 */
//ToString and equals/hashcode autogenerated
@Getter
@ToString
@EqualsAndHashCode
public class AtmosphericInformation implements DeepCloned
{
	private static final long serialVersionUID = 369269490742979859L;

	/** milliseconds in a day */
    private static final long DAY_MILLIS = 86400000;

    /** temperature in degrees celsius */
    private DataPoint temperature;

    /** wind speed in km/h */
    private DataPoint wind;

    /** humidity in percent */
    private DataPoint humidity;

    /** precipitation in cm */
    private DataPoint precipitation;

    /** pressure in mmHg */
    private DataPoint pressure;

    /** cloud cover percent from 0 - 100 (integer) */
    private DataPoint cloudCover;

    /** the last time this data was updated, in milliseconds since UTC epoch */
    @JsonIgnore
    private long lastUpdateTime = 0;
    
    public AtmosphericInformation()
    {
    	this(null, null, null, null, null, null);
    }
    
    public AtmosphericInformation(DataPoint temperature, DataPoint wind, DataPoint humidity, 
    							  DataPoint precipitation, DataPoint pressure, DataPoint cloudCover) 
    {
        this.temperature = temperature;
        this.wind = wind;
        this.humidity = humidity;
        this.precipitation = precipitation;
        this.pressure = pressure;
        this.cloudCover = cloudCover;
        
        if(notEmpty())
        	touch();
    }
    
    public boolean notEmpty()
    {
    	return cloudCover != null || 
    		   humidity != null ||
               pressure != null ||
               precipitation != null ||
               temperature != null ||
               wind != null;
    }
    
    public boolean recentReaded()
    {
    	return notEmpty() && lastUpdateTime > System.currentTimeMillis() - DAY_MILLIS;
    }
    
    /**
     * update atmospheric information with the given data point for the given point type
     *
     * @param pointType the data point type as a string
     * @param dp the actual data point
     */
    public synchronized void updateAtmosphericInformation(DataPointType pointType, DataPoint point)
    {
    	Optional<DataPoint> dp = Optional.ofNullable(point.copy());

    	switch(pointType)
    	{
    		case WIND:
    	    	dp.filter(d -> d.getMean() >= 0).ifPresent(d -> wind = d);
                break;
    		case TEMPERATURE:
    	    	dp.filter(d -> d.getMean() >= -50 && d.getMean() < 100).ifPresent(d -> temperature = d);
                break;
    		case HUMIDITY:
    	    	dp.filter(d -> d.getMean() >= 0 && d.getMean() < 100).ifPresent(d -> humidity = d);
                break;
    		case PRESSURE:
    	    	dp.filter(d -> d.getMean() >= 650 && d.getMean() < 800).ifPresent(d -> pressure = d);
                break;
    		case CLOUDCOVER:
    	    	dp.filter(d -> d.getMean() >= 0 && d.getMean() < 100).ifPresent(d -> cloudCover = d);
                break;
    		case PRECIPITATION:
    	    	dp.filter(d -> d.getMean() >=0 && d.getMean() < 100).ifPresent(d -> precipitation = d);
                break;
            default:
            	return;
    	}
    	
    	touch();
    }  
    
    /**
     * Each time a field is modified, the lastUpdateTime is updated
     * 
     */
    private void touch()
    {
    	lastUpdateTime = System.currentTimeMillis();
    }
}
