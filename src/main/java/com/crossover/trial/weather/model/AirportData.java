package com.crossover.trial.weather.model;

import java.util.Arrays;
import java.util.List;

import com.crossover.trial.weather.exceptions.WeatherException;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.AccessLevel;

// Getters, Setters, ToString and equals/hashcode autogenerated
@Getter
@Setter
@ToString
@EqualsAndHashCode
public class AirportData implements DeepCloned
{
	private static final long serialVersionUID = 8402413424181987920L;

	private static final List<String> DST_LIST = Arrays.asList("E", "A", "S", "O", "Z", "N", "U");

    private static final Double LAT_MIN = -90.0;
    private static final Double LAT_MAX = 90.0;
    private static final Double LON_MIN = -180.0;
    private static final Double LON_MAX = 180.0;
    
    /** earth radius in KM */
    private static final double R = 6372.8;

	private String name;
    private String city;
    private String country;
    private String iata;
    private String icao;
    private double lat;
    private double lon;
    private double alt;
    private double timezone;
    private String dst;
    
    @Setter(AccessLevel.NONE)
    private Integer requestFrequency = 0;
    
    @Setter(AccessLevel.NONE)
    private AtmosphericInformation atmosphericInformation;
    
    public AirportData() 
    {
        atmosphericInformation = new AtmosphericInformation();
        requestFrequency = 0;
	}
    
    public synchronized void incrementRequestFrecuency()
    {
    	requestFrequency++;
    }
    
    public synchronized void copyFrom(AirportData d)
    {
    	setName(d.getName());
    	setCity(d.getCity());
    	setCountry(d.getCountry());
    	setIata(d.getIata());
    	setIcao(d.getIcao());
    	setAlt(d.getAlt());
    	setLat(d.getLat());
    	setLon(d.getLon());
    	setDst(d.getDst());
    	requestFrequency = d.getRequestFrequency();
    	atmosphericInformation = DeepCloned.copy(d.getAtmosphericInformation());
    }
    
    /**
     * Haversine distance between two airports.
     *
     * @param ad airport 1
     * @return the distance in KM
     */
    public double calculateDistanceTo(AirportData ad) 
    {
        double deltaLat = Math.toRadians(ad.getLat() - lat);
        double deltaLon = Math.toRadians(ad.getLon() - lon);
        double a =  Math.pow(Math.sin(deltaLat / 2), 2) + Math.pow(Math.sin(deltaLon / 2), 2)
                	* Math.cos(lat) * Math.cos(ad.getLat());
        double c = 2 * Math.asin(Math.sqrt(a));
        return R * c;
    }
    
    /**
     * Validate the fields of an object airport
     * 
     * @param ad the Airport to validate
     */
    public static void validateData(AirportData ad)
    {
    	if(ad != null)
    	{
    		checkIata(ad.getIata());
    		checkIcao(ad.getIcao());
    		checkDst(ad.getDst());
    		checkLatitude(ad.getLat());
    		checkLongitude(ad.getLon());
    	}
    	else
    		throw new WeatherException("AirportData is empty.");
    }
    
    private static void checkIata(String iata)
    {
		if(iata != null && iata.trim().length() > 3)
			throw new WeatherException("IATA/FAA code not valid : " + iata);
    }
    
    private static void checkIcao(String icao)
    {
		if(icao != null && icao.trim().length() > 4)
			throw new WeatherException("ICAO code not valid : " + icao);
    }
    
    private static void checkDst(String dst)
    {
		if(dst != null && !DST_LIST.contains(dst.toUpperCase()))
			throw new WeatherException("DST code not valid : " + dst);
    }
    
    private static void checkLatitude(double latitude)
    {
		if(Double.compare(latitude, LAT_MIN) < 0 || Double.compare(latitude, LAT_MAX) > 0)
			throw new WeatherException("Latitude error.: " + latitude);	
    }
    
    private static void checkLongitude(double longitude)
    {
    	if(Double.compare(longitude, LON_MIN) < 0 || Double.compare(longitude, LON_MAX) > 0)
			throw new WeatherException("Longitude error.: " + longitude);    	
    }
}
