package com.crossover.trial.weather.model;

import java.util.Arrays;
import java.util.List;

import com.crossover.trial.weather.exceptions.WeatherException;

import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

// Getters, ToString and equals/hashcode autogenerated
@Getter
@ToString
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.NONE)
public class AirportData implements DeepCloned
{
	private static final long serialVersionUID = 8402413424181987920L;

	private static final List<String> DST_LIST = Arrays.asList("E", "A", "S", "O", "Z", "N", "U");

    private static final Double LAT_MIN = -90.0;
    private static final Double LAT_MAX = 90.0;
    private static final Double LON_MIN = -180.0;
    private static final Double LON_MAX = 180.0;
    
    /** earth radius in KM */
    private static final double R = 6372.8;

	private String name;
    private String city;
    private String country;
    private String iata;
    private String icao;
    private double lat;
    private double lon;
    private double alt;
    private double timezone;
    private String dst;
    private Integer requestFrequency = 0;
    private AtmosphericInformation atmosphericInformation = new AtmosphericInformation();    
    
    public synchronized void incrementRequestFrecuency()
    {
    	requestFrequency++;
    }
    
    /**
     * Haversine distance between two airports.
     *
     * @param ad airport 1
     * @return the distance in KM
     */
    public double calculateDistanceTo(AirportData ad) 
    {
        double deltaLat = Math.toRadians(ad.getLat() - lat);
        double deltaLon = Math.toRadians(ad.getLon() - lon);
        double a =  Math.pow(Math.sin(deltaLat / 2), 2) + Math.pow(Math.sin(deltaLon / 2), 2)
                	* Math.cos(lat) * Math.cos(ad.getLat());
        double c = 2 * Math.asin(Math.sqrt(a));
        return R * c;
    }
    
    public void validate()
    {
    	checkIata();
    	checkIcao();
    	checkLatitude();
    	checkLongitude();
    	checkDst();
    }
    
    private void checkIata()
    {
		if(iata != null && iata.trim().length() > 3)
			throw new WeatherException("IATA/FAA code not valid : " + iata);
    }
    
    private void checkIcao()
    {
		if(icao != null && icao.trim().length() > 4)
			throw new WeatherException("ICAO code not valid : " + icao);
    }
    
    private void checkDst()
    {
		if(dst != null && !DST_LIST.contains(dst.toUpperCase()))
			throw new WeatherException("DST code not valid : " + dst);
    }
    
    private void checkLatitude()
    {
		if(Double.compare(lat, LAT_MIN) < 0 || Double.compare(lat, LAT_MAX) > 0)
			throw new WeatherException("Latitude error.: " + lat);	
    }
    
    private void checkLongitude()
    {
    	if(Double.compare(lon, LON_MIN) < 0 || Double.compare(lon, LON_MAX) > 0)
			throw new WeatherException("Longitude error.: " + lon);    	
    }
    
    public static class AirportDataBuilder
    {
    	private String name;
        private String city;
        private String country;
        private String iata;
        private String icao;
        private double lat;
        private double lon;
        private double alt;
        private double timezone;
        private String dst;
        
		public AirportDataBuilder withName(String name) 
		{
			this.name = name;
			return this;
		}
		
		public AirportDataBuilder withCity(String city) 
		{
			this.city = city;
			return this;
		}
		public AirportDataBuilder withCountry(String country) 
		{
			this.country = country;
			return this;
		}
		
		public AirportDataBuilder withIata(String iata) 
		{
			this.iata = iata.toUpperCase();
			return this;
		}
		
		public AirportDataBuilder withIcao(String icao) 
		{
			this.icao = icao.toUpperCase();
			return this;
		}
		
		public AirportDataBuilder withLat(double lat) 
		{
			this.lat = lat;
			return this;
		}
		
		public AirportDataBuilder withLon(double lon) 
		{
			this.lon = lon;
			return this;
		}
		
		public AirportDataBuilder withAlt(double alt) 
		{
			this.alt = alt;
			return this;
		}
		
		public AirportDataBuilder withTimezone(double timezone) 
		{
			this.timezone = timezone;
			return this;
		}
		
		public AirportDataBuilder withDst(String dst) 
		{
			this.dst = dst;
			return this;
		}
		
		public AirportData build()
		{
			AirportData data = new AirportData();
			data.alt = alt;
			data.city = city;
			data.country = country;
			data.dst = dst;
			data.iata = iata;
			data.icao = icao;
			data.lat = lat;
			data.lon = lon;
			data.name = name;
			data.timezone = timezone;
			
			return data;			
		}
    }
}
